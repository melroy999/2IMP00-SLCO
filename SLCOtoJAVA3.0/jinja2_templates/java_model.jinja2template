import java.util.Random;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Arrays;

// Main class
@SuppressWarnings({"NonAtomicOperationOnVolatileField", "SpellCheckingInspection", "FieldMayBeFinal", "IfStatementWithIdenticalBranches", "FieldCanBeLocal"})
public class {{model.name}} {
    // The objects in the model
    private final SLCO_Class[] objects;

    {% if model.include_lock_manager %}
    // Lock class to handle locks of global variables
    private static class LockManager {
        // The locks
        private final ReentrantLock[] locks;

        LockManager(int noVariables) {
            locks = new ReentrantLock[noVariables];
            for(int i = 0; i < locks.length; i++) {
                locks[i] = new ReentrantLock({{ "true" if model.lock_fairness else "false" }});
            }
        }

        // Lock method
        void lock(LockRequest[] lock_ids, int start, int end) {
            int i = start;
            Arrays.sort(lock_ids, start, end);
            for (; i < end; i++) {
                if(lock_ids[i].isValid()) {
                    locks[lock_ids[i].getIdentity()].lock();
                }
            }
        }

        // Unlock method
        void unlock(LockRequest[] lock_ids, int end) {
            for (int i = 0; i < end; i++) {
                if(lock_ids[i].isValid()) {
                    locks[lock_ids[i].getIdentity()].unlock();
                }
            }
        }

        // Unlock method during exceptions
        void exception_unlock() {
            System.err.println("Exception encountered. Releasing all locks currently owned by " + Thread.currentThread().getName() + ".");
            for(ReentrantLock lock: locks) {
                while(lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            }
        }
    }

    // A representation of a lock request that can be used to validate the validity thereof.
    private static class LockRequest implements Comparable<LockRequest> {
        private int identity;
        private boolean validity;

        boolean isValid() {
            return validity;
        }

        int getIdentity() {
            return identity;
        }

        void set(int identity, int offset, int length) {
            this.identity = identity + offset;
            this.validity = offset >= 0 && offset < length;
        }

        @Override
        public int compareTo(LockRequest request) {
            return this.identity - request.identity;
        }
    }

    {% endif %}
    // Template for SLCO classes
    interface SLCO_Class {
        void startThreads();
        void joinThreads();
    }

    {% for c in model.classes %}
    {{c | render_class | indent(4, False)}}

    {% endfor %}
    {{model.name}}() {
        //Instantiate the objects
        objects = new SLCO_Class[] {
            {% for c in model.classes %}
            {% for variable_list in c.variable_lists_for_class_instantiations %}
            {% if c.variables | length < 2 %}
            new {{c.name}}({{variable_list | join(", ")}}),
            {% else %}
            new {{c.name}}(
                {% for v in variable_list %}
                {{v}}{{"," if not loop.last}}
                {% endfor %}
            ),
            {% endif %}
            {% endfor %}
            {% endfor %}
        };
    }

    // Start all threads
    private void startThreads() {
        for(SLCO_Class o : objects) {
            o.startThreads();
        }
    }

    // Join all threads
    private void joinThreads() {
        for(SLCO_Class o : objects) {
            o.joinThreads();
        }
    }

    // Run application
    public static void main(String[] args) {
        {{model.name}} ap = new {{model.name}}();
        ap.startThreads();
        ap.joinThreads();
    }
}