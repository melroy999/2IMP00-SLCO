model dve_driving_phils_1 {
classes
	GlobalClass {
		variables
			Byte[2] request
			Byte[2] starvers
			Byte[2] resources
			Integer[2] res0
			Integer[2] res1
			Integer[2] acquiring
			Integer entryRound := 1
			Byte phase := 0
			Byte fire := 0
		state machines
			round_about {
				variables
					Integer i := 0
				initial reset
				states  begin0 begin1 begin2 begin3 action end0 end1 end2
				transitions
					from reset to reset {
						[i < 2; res0[i] := -1;res1[i] := -1;acquiring[i] := -1;i := i+1]
					}

					from reset to begin0 {
						[i = 2; i := 0;phase := 0]
					}

					from begin0 to begin0 {
						[i < 2; resources[i] := 0;i := i+1]
					}

					from begin0 to begin1 {
						[i = 2; i := 0]
					}

					from begin1 to begin1 {
						[i < 2 and res0[i] <> -1; resources[res0[i]*2] := entryRound;resources[res0[i]*2+1] := i;i := i+1]
					}

					from begin1 to begin1 {
						[i < 2 and res0[i] = -1; i := i+1]
					}

					from begin1 to begin2 {
						[i = 2; i := 0]
					}

					from begin2 to begin2 {
						[i < 2 and res1[i] <> -1; resources[res1[i]*2] := entryRound;resources[res1[i]*2+1] := i;i := i+1]
					}

					from begin2 to begin2 {
						[i < 2 and res1[i] = -1; i := i+1]
					}

					from begin2 to action {
						[i = 2; i := 0;phase := 1;fire := 0]
					}

					from action to end0 {
						[fire = 2; fire := 0;phase := 2]
					}

					from end0 to end0 {
						[i < 1 and resources[2*i] <> 0; request[1*resources[2*i+1]+i] := 0;starvers[1*resources[2*i+1]+i] := 0;i := i+1]
					}

					from end0 to end0 {
						[i < 1 and resources[2*i] = 0; i := i+1]
					}

					from end0 to end1 {
						[i = 1; i := 0]
					}

					from end1 to end1 {
						[i < 2; i := i+1]
					}

					from end1 to begin0 {
						[i = 2 and fire = 2; phase := 0;i := 0]
					}

				}
	
			phil_0 {
				variables
					Integer i := 0
				initial action
				states  end5 mutex
				transitions
					from action to end5 {
						[phase = 1 and res0[0] <> -1; resources[res0[0]] := 0;resources[res0[0]+1] := 0;res0[0] := res1[0];res1[0] := -1;fire := fire + 1]
					}

					from action to end5 {
						[phase = 1 and res1[0] = -1 and acquiring[0] = -1; acquiring[0] := 0;fire := fire + 1;request[0*1+0] := entryRound]
					}

					from action to end5 {
						[phase = 1; fire := fire + 1]
					}

					from end5 to action {
						[phase = 2 and acquiring[0] = -1; fire := fire+1]
					}

					from end5 to mutex {
						phase = 2 and acquiring[0] <> -1 and fire = 0
					}

					from mutex to mutex {
						[i < 2 and res0[i] <> acquiring[0] and res1[i] <> acquiring[0]; i := i + 1]
					}

					from mutex to action {
						[i < 2 and (res0[i] = acquiring[0] or res1[i] = acquiring[0]); fire := fire + 1;i := i + 1]
					}

					from mutex to action {
						[i = 2 and res0[0] = -1; res0[0] := acquiring[0];acquiring[0] := -1;fire := fire + 1;i := 0]
					}

					from mutex to action {
						[i = 2 and res0[0] <> -1; res1[0] := acquiring[0];acquiring[0] := -1;fire := fire + 1;i := 0]
					}

					from end5 to action {
						[phase = 2 and acquiring[0] <> -1; fire := fire + 1]
					}

				}
	
			phil_1 {
				variables
					Integer i := 0
				initial action
				states  end6 mutex
				transitions
					from action to end6 {
						[phase = 1 and res0[1] <> -1; resources[res0[1]] := 0;resources[res0[1]+1] := 0;res0[1] := res1[1];res1[1] := -1;fire := fire + 1]
					}

					from action to end6 {
						[phase = 1 and res1[1] = -1 and acquiring[1] = -1; acquiring[1] := 0;fire := fire + 1;request[1*1+0] := entryRound]
					}

					from action to end6 {
						[phase = 1; fire := fire + 1]
					}

					from end6 to action {
						[phase = 2 and acquiring[1] = -1; fire := fire+1]
					}

					from end6 to mutex {
						phase = 2 and acquiring[1] <> -1 and fire = 1
					}

					from mutex to mutex {
						[i < 2 and res0[i] <> acquiring[1] and res1[i] <> acquiring[1]; i := i + 1]
					}

					from mutex to action {
						[i < 2 and (res0[i] = acquiring[1] or res1[i] = acquiring[1]); fire := fire + 1;i := i + 1]
					}

					from mutex to action {
						[i = 2 and res0[1] = -1; res0[1] := acquiring[1];acquiring[1] := -1;fire := fire + 1;i := 0]
					}

					from mutex to action {
						[i = 2 and res0[1] <> -1; res1[1] := acquiring[1];acquiring[1] := -1;fire := fire + 1;i := 0]
					}

					from end6 to action {
						[phase = 2 and acquiring[1] <> -1; fire := fire + 1]
					}

				}
	
	}

objects
	globalObject : GlobalClass()
}
